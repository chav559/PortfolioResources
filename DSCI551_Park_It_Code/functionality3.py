# -*- coding: utf-8 -*-
"""functionality3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1CykgmtFBG4hGf58n0ADL8uS13ZH5GdD-
"""

import json
import requests
from datetime import datetime
import pandas as pd



import googlemaps
#Set Google MAPS API_Key
g_API = "AIzaSyDYDVUyBArHNfFjZnFC12iiv3LadNfwK54"
gmaps_key = googlemaps.Client(key=g_API)



# base url of my firebase project's realtime database
fb_url = "https://dsci551-project-parking-app-default-rtdb.firebaseio.com/"
json_ext = ".json"

daysL = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"]
daysL_full = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"]



# function 3

# At the top include a short explanation of the functionality; ie what it is used for ???


# user will need to input their address; as well as (if they want)
# filter criteria: 
#     choice of parking locations (street, not street, garage, lot)
#     availability    
#     valet
#     min safety
#     no restrictions
#     output limit (max 20 or 25); default is 5

# sort criteria: distance, duration, safety (use base safety)


# user input: street number, street name, zip code, city, and choose 1 or 3 parking types (optional)
# based on front-end output

# give user option to select weekday and time ???; if time; do later; probably not



# # Optional (Default below)
# # choice of parking locations (street, not street, garage, lot)
# parking_type_cond = None
# availability_cond = None
# valet_cond = None 
# min_safety_cond = 0
# # make sure min_safety_cond is a digit ???; otherwise the code will be an error
# no_restrictions_cond = None 
# output_limit_cond = 5
# sort_cond = "safety"



def parking_list(street_num, street_name, zip_code, city, state, parking_type_cond=None, availability_cond=None, valet_cond=None, min_safety_cond=0, no_restrictions_cond=None, output_limit_cond=5, sort_cond="safety"):
    state = "CA"
    
    if (type(min_safety_cond) == int) or ( (type(min_safety_cond) == str) and (min_safety_cond.isdigit()) ):
        min_safety_cond = int(min_safety_cond)
    else:
        min_safety_cond = 0
    


    # firebase has only filtering by only 1 orderBy attribute

    # need to decide what criteria to query by
    # the rest is filtered internally
    # so we need to determine the order of filtering that reduces the greatest number

    # availability == True: it is whatever we previously set, otherwise it is blank
    # valet == True: returns 24 locations
    # parking_type == "Lot": returns 37 locations
    # parking_type == "Garage": returns 40 locations
    # parking_type == "Lot" or "Garage": returns 77 locations
    # min_safety >= 73: returns 256- locations
    # parking_type == "Street parking": returns 258 locations
    # min_safety < 73 but > 63: returns 267+ locations
    # valet == False: returns 311 locations
    # no_restrictions == True: returns 311 locations
        # doesn't help much and hard to configure; exclude
    # min_safety <= 63: returns 312+ locations
    # else (ie no filteres): returns 335 locations

    # parking_type_cond = None
    # availability_cond = None
    # valet_cond = None 
    # min_safety_cond = None
    # no_restrictions_cond = None 


    # make sure the input variable spellings match (eg Not street parking)
    if availability_cond:
        get = requests.get(fb_url + json_ext + '?orderBy="updated"&equalTo=true')
        parking_locsD = get.json()
    #     print(1)
    elif (valet_cond) and (valet_cond == True):
        get = requests.get(fb_url + json_ext + '?orderBy="valet"&equalTo=true')
        parking_locsD = get.json()
    #     print(2)
    elif (parking_type_cond) and (parking_type_cond == "Lot"):
        get = requests.get(fb_url + json_ext + '?orderBy="type"&equalTo="Lot"')
        parking_locsD = get.json()
    #     print(3)
    elif (parking_type_cond) and (parking_type_cond == "Garage"):
        get = requests.get(fb_url + json_ext + '?orderBy="type"&equalTo="Garage"')
        parking_locsD = get.json()
    #     print(4)
    elif (parking_type_cond) and (parking_type_cond == "Not street parking"):
        # does Firebase query not have an "or" or "in" operator ???; need two queries
        get = requests.get(fb_url + json_ext + '?orderBy="type"&equalTo="Garage"')
        parking_locsD1 = get.json()
        get = requests.get(fb_url + json_ext + '?orderBy="type"&equalTo="Lot"')
        parking_locsD2 = get.json()
        # joining the two dicts
    #     print(4)
        parking_locsD = { **parking_locsD1 , **parking_locsD2 }
    elif (min_safety_cond) and (int(min_safety_cond) >= 73):
        get = requests.get(fb_url + json_ext + '?orderBy="safety score"&startAt=%i' %min_safety_cond)
        parking_locsD = get.json()
    #     print(5)
    elif (parking_type_cond) and (parking_type_cond == "Street parking"):
        get = requests.get(fb_url + json_ext + '?orderBy="type"&equalTo="Garage"')
        parking_locsD = get.json()
    #     print(6)
    elif (min_safety_cond) and (int(min_safety_cond) >= 65) and (int(min_safety_cond) <= 72):
        get = requests.get(fb_url + json_ext + '?orderBy="safety score"&startAt=%i' %min_safety_cond)
        parking_locsD = get.json()
    #     print(7)
    elif (valet_cond) and (valet_cond == False):
        get = requests.get(fb_url + json_ext + '?orderBy="valet"&equalTo=false')
        parking_locsD = get.json()
    #     print(8)
    else:
        get = requests.get(fb_url + json_ext + '?orderBy="safety score"&startAt=%i' %min_safety_cond)
        parking_locsD = get.json()
    #     print(9)


    # parking_locsD = parking_locsD_copy.copy()
    parking_locsD_copy = parking_locsD.copy()




    # continuing the filtering
    # delete parking loc item if it doesn't meet the criteria

    deletedL = []
    for loc_id, locationD in parking_locsD_copy.items():

        if (parking_type_cond == "Garage") and (locationD["type"] != "Garage"):
            del parking_locsD[loc_id]
            deletedL.append(loc_id)
            continue
        elif (parking_type_cond == "Lot") and (locationD["type"] != "Lot"):
            del parking_locsD[loc_id]
            deletedL.append(loc_id)
            continue
        elif (parking_type_cond == "Not street parking") and (locationD["type"] == "Street parking"):
            del parking_locsD[loc_id]
            deletedL.append(loc_id)
            continue

        if (availability_cond) and ("updated" not in locationD):
            del parking_locsD[loc_id]
            deletedL.append(loc_id)
            continue

        if (no_restrictions_cond) and ("restrictions" in locationD):
            del parking_locsD[loc_id]
            deletedL.append(loc_id)
            continue

        # valet_cond == True means "offers valet"
        if (valet_cond == True) and (locationD["valet"] == False):
            del parking_locsD[loc_id]
            deletedL.append(loc_id)
            continue
        elif (valet_cond == False) and (locationD["valet"] == True):
            del parking_locsD[loc_id]
            deletedL.append(loc_id)
            continue

        if (min_safety_cond) and (locationD["safety score"] < int(min_safety_cond)):
            del parking_locsD[loc_id]
            deletedL.append(loc_id)
            continue





        # implicit filter condition that the parking location is open at that day and time

        # *****
        loc_type = locationD["type"]
        if "no parking" in locationD:
            no_parkingL = locationD["no parking"]
        else:
            no_parkingL = None

        now = datetime.now()

        hour_now = now.hour
        weekday_now = daysL[now.weekday()]

        if now.weekday() == 6:
            weekday_tomorrow = daysL[0]
        else:
            weekday_tomorrow = daysL[now.weekday()+1]


        closed = True
        today_ratesL = []
        tomorrow_ratesL = []
        # yesterday_ratesL = []

        if "rates" in locationD:
            for rateD in locationD["rates"]:
        #         print(rateD)

                if weekday_now == rateD["day"]:
                    today_ratesL.append(rateD)
                elif weekday_tomorrow == rateD["day"]:
                    tomorrow_ratesL.append(rateD)

        today_flatFeeL = []
        tomorrow_flatFeeL = []

        if "flat fees" in locationD:
            for flatfeeD in locationD["flat fees"]:

                if weekday_now == flatfeeD["day"]:
                    today_flatFeeL.append(flatfeeD)
                elif weekday_tomorrow == flatfeeD["day"]:
                    tomorrow_flatFeeL.append(flatfeeD)

        if (len(today_ratesL) == 0) and (len(today_flatFeeL) == 0):
                del parking_locsD[loc_id]
                deletedL.append(loc_id)
                continue



        for i in range(len(today_ratesL)):
            deleted = False
            
            range_start = today_ratesL[i]["time range"].split("-")[0]
            range_end = today_ratesL[i]["time range"].split("-")[1]

            range_start_int = int(range_start[:2])
            range_end_int = int(range_end[:2])


            if loc_type == "Street Parking":
                if (not no_parkingL):
                    closed = False
                    continue

                else:
                    for no_parkD in no_parkingL:
                        if weekday_now == no_parkD["day"]:
                            range_start = today_ratesL[i]["time range"].split("-")[0]
                            range_end = today_ratesL[i]["time range"].split("-")[1]
                            range_start_int = int(range_start[:2])
                            range_end_int = int(range_end[:2])

#                             deleted = False
                            if (hour_now >= range_start_int) and (hour_now < range_end_int):
                                if loc_id not in deletedL:
                                    del parking_locsD[loc_id]
                                    deletedL.append(loc_id)
                                    deleted = True
                                    continue
                    if deleted:
                        continue

                    closed = False
                    continue

            elif (hour_now < range_start_int) or (hour_now >= range_end_int):
                if loc_id not in deletedL:
                    del parking_locsD[loc_id]
                    deletedL.append(loc_id)
                    deleted = True
                    continue
            if deleted:
                continue


        for i in range(len(today_flatFeeL)):
            range_start = today_flatFeeL[i]["time range"].split("-")[0]
            range_end = today_flatFeeL[i]["time range"].split("-")[1]

            range_start_int = int(range_start[:2])
            range_end_int = int(range_end[:2])

            if (hour_now < range_start_int) or (hour_now > range_end_int):
                if loc_id not in deletedL:
                    del parking_locsD[loc_id]
                    deletedL.append(loc_id)
                    deleted = True
                    continue




    # sort the remaining parking items based on the sort_cond

    # first we add tuples of each parking element with its parking dictionary and sorting condition
    # if sort_cond == "safety", second tuple will be its new safety (post citizen)
    # if it is distance or duration, it will be two tuples added for distance and duration

    parking_locsD_sortedL = []
    query_address = street_num + " " + street_name + ", " + city + ", " + state + " " + zip_code
    
    # using the googlemaps API
    coordinate_infoD = gmaps_key.geocode(query_address)
    user_lat = coordinate_infoD[0]["geometry"]["location"]["lat"]
    user_long = coordinate_infoD[0]["geometry"]["location"]["lng"]
    user_cordD = {"lat":user_lat, "long":user_long}
    

    if sort_cond == "safety":
        for loc_i, locationD in parking_locsD.items():
            parking_locsD_sortedL.append( (loc_i, locationD, locationD["safety score"]) )

    elif (sort_cond == "distance") or (sort_cond == "duration"):
        for loc_i, locationD in parking_locsD.items():

            parking_address = locationD["address"]["street number"] + " " + locationD["address"]["street"] + ", " + locationD["address"]["city"] + ", " + locationD["address"]["state"] + " " + locationD["address"]["zip code"]

            dist_infoD = gmaps_key.distance_matrix(query_address, parking_address, units="imperial")['rows'][0]['elements'][0]
            distance = dist_infoD["distance"]["text"]
            duration = dist_infoD["duration"]["text"]

            parking_locsD_sortedL.append( (loc_i, locationD, distance, duration) )


    if sort_cond == "safety":
        parking_locsD_sortedL.sort(key = lambda x:x[2], reverse=True)
    elif sort_cond == "distance":
        parking_locsD_sortedL.sort(key = lambda x:x[2])
    elif sort_cond == "duration":
        parking_locsD_sortedL.sort(key = lambda x:x[3]) 




    # creating dataframe
    rowsL = []

    if sort_cond == "safety":
        for loc_i, locationD, safety in parking_locsD_sortedL[:output_limit_cond]:

            parking_address = locationD["address"]["street number"] + " " + locationD["address"]["street"] + ", " + locationD["address"]["city"] + ", " + locationD["address"]["state"] + " " + locationD["address"]["zip code"]
            lat = locationD["coordinates"]["latitude"]
            long = locationD["coordinates"]["longitude"]
            
            dist_infoD = gmaps_key.distance_matrix(query_address, parking_address, units="imperial")['rows'][0]['elements'][0]
            distance = dist_infoD["distance"]["text"]
            duration = dist_infoD["duration"]["text"]
            pType = locationD["type"]

            rowsL.append( (loc_i, parking_address, pType, distance, duration, safety, lat, long) )

    elif sort_cond == "distance":
        for loc_i, locationD, distance, duration in parking_locsD_sortedL[:output_limit_cond]:
            parking_address = locationD["address"]["street number"] + " " + locationD["address"]["street"] + ", " + locationD["address"]["city"] + ", " + locationD["address"]["state"] + " " + locationD["address"]["zip code"]
            safety = locationD["safety score"]
            pType = locationD["type"]
            lat = locationD["coordinates"]["latitude"]
            long = locationD["coordinates"]["longitude"]

            rowsL.append( (loc_i, parking_address, pType, distance, duration, safety, lat, long) )

    elif sort_cond == "duration":
        for loc_i, locationD, distance, duration in parking_locsD_sortedL[:output_limit_cond]:
            parking_address = locationD["address"]["street number"] + " " + locationD["address"]["street"] + ", " + locationD["address"]["city"] + ", " + locationD["address"]["state"] + " " + locationD["address"]["zip code"]
            safety = locationD["safety score"]
            pType = locationD["type"]
            lat = locationD["coordinates"]["latitude"]
            long = locationD["coordinates"]["longitude"]

            rowsL.append( (loc_i, parking_address, pType, distance, duration, safety, lat, long) )


    parking_df = pd.DataFrame(rowsL, columns = ["ID", "Address", "Parking Type", "Distance", "Duration", "Safety Score", "lat", "lon"])
    return parking_df, user_cordD



# user input
street_num = "6735"
street_name = "Yucca"
zip_code = "90028"
city = "Los Angeles"
state = "CA"

# optional input example
parking_type_cond = "Not street parking"
min_safety_cond = 70
sort_cond = "safety"
# sort_cond = "distance"

# parking_df, cordD = parking_list(street_num, street_name, zip_code, city, state, parking_type_cond=None, availability_cond=None, valet_cond=None, min_safety_cond=0, no_restrictions_cond=None, output_limit_cond=5, sort_cond = "safety")
parking_df, cordD = parking_list(street_num, street_name, zip_code, city, state, parking_type_cond=parking_type_cond, min_safety_cond=min_safety_cond, sort_cond=sort_cond)

print(parking_df)

cordD





# parking_df

# parking_df

