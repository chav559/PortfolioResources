# -*- coding: utf-8 -*-
"""Parsing_HTML_Scrape.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/12r6FStigzymg7A-UJqKzGC64qMLL7A4k
"""

from bs4 import BeautifulSoup
import requests
import sqlite3
import time
from tqdm import tqdm
from selenium import webdriver
from selenium.webdriver.common.keys import Keys 

from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
import undetected_chromedriver as uc
from selenium import webdriver

import pickle

import sys
sys.setrecursionlimit(30000)

import re
import random





# dictionary with a street name as the key, and a 1 or a 0 as the value
# If the value is 1, the street is a main/active street with lots of foot traffic (or is otherwise safe); 0 means the inverse

main_streetsD = {
'Afton Pl':0, 'Argyle Ave':0, 'Banner Ave':0, 'Barton Ave':0, 'Cahuenga Blvd':1, 'Cole Pl':0, 'Cosmo St':0,
'De Longpre Ave':0, 'El Cerrito Pl':0, 'Franklin Ave':1, 'Gordon St':0, 'Gordon Street':0, 'Gower Street':0,
'Hawthorn Ave':0, 'Hollywood Blvd':1, 'Ivar Ave':0, 'La Mirada Ave':0, 'Leland Way':0, 'Lemon Grove Ave':0,
'Lexington Ave':0, 'Lexington Avenue':0, 'Lillian Way':0, 'Marathon St':0, 'Melrose Ave':1, 'N Cahuenga Blvd':1,
'N Cherokee Ave':0, 'N Citrus Ave':0, 'N El Centro Ave':0, 'N Garfield Pl':0, 'N Gower St':0, 'N Gramercy Pl':0,
'N Highland Ave':1, 'N Hudson Ave':0, 'N La Brea Ave':1, 'N Las Palmas Ave':0, 'N Mansfield Ave':0,
'N McCadden Pl':0, 'N Orange Dr':0, 'N St Andrews Pl':0, 'N Sycamore Ave':0, 'N Vine St':1, 'N Wilton Pl':0,
'North La Brea Avenue':1, 'Romaine St':0, 'Romaine Street':0, 'Santa Monica Blvd':1, 'Schrader Blvd':0,
'Selma Ave':0, 'Seward St':0, 'Seward Street':0, 'Sierra Vista Ave':0, 'St Andrews Pl':0, 'Sunset Blvd':1,
'Sunset Boulevard':1, 'Taft Ave':1, 'Vine St':1, 'Vine Street':1, 'Virginia Ave':1,'W Hollywood Blvd':1,
'W Melrose Ave':1, 'W Sunset Blvd':1, 'W Willoughby Ave':1, 'W. Sunset Blvd':1, 'Waring Ave':1, 'Whitley Ave':0,
'Wilcox Ave':1, 'Yucca St':0}

with open ("loc_crimesD", "rb") as f:
    loc_crimesD = pickle.load(f)





with open ("loc_elems_dict", "rb") as f:
    loc_elems = pickle.load(f)

len(loc_elems)

def remove_redundancies(old_list):
    removeL = []
    new_list = old_list.copy()
        
    for info1 in old_list:
        for info2 in old_list:
            if (info2 == "Month (Unreserved)") or (info2 == "Month (Reserved)") or (info2 == "No Parking - Brooming"):
                continue
            # exception for 117 and 172
            elif (info1 in info2) and (info1 != info2):
                
                removeL.append(info2)
#                 print(info1, "\n", info2)
#                 print()

    for info in set(removeL):
        new_list.remove(info)
    
    return new_list

def convertToMilitaryT(time):
    hr = int(time[:-5])
    md = time[-2:]
    # Special-case '12AM' -> 0, '12PM' -> 12 (not 24)
    if (hr == 12):
        hr = 0
    if (md == 'pm'):
        hr += 12
    military_time = ("%02d" % hr + ":" + time[-4:-2])
    return military_time

def isfloat(n):
     try:
        float(n)
        return True
     except ValueError:
        return False

# loc_elems["location 288"]["url"]

del loc_elems["location 7"]
del loc_elems["location 92"]
del loc_elems["location 111"]
del loc_elems["location 141"]
del loc_elems["location 146"]
del loc_elems["location 235"]
del loc_elems["location 266"]

url_listL = []
edit_listL = []

parking_locationsD = {}
parking_locationsL = []


# for i in range(len(loc_elems)):
for loc_i in range(len(loc_elems)+7):
    
    try:
        
        if (loc_i == 7) or (loc_i == 92) or (loc_i == 111) or (loc_i == 141) or (loc_i == 146) or (loc_i == 235) or (loc_i == 266):
            continue
        
#         print(loc_i)
        url_listL.append(loc_elems["location "+str(loc_i)]["url"])
        

        locationContent_elem = loc_elems["location "+str(loc_i)]["element"]


        type_spots = locationContent_elem.find(class_="LocationDetailsTitleBar__subTitle").get_text()


    #     type_spots = locationContent_elem.find(class_="LocationDetailsTitleBar__subTitle").get_text()
        if "Street" in type_spots:
            Type = type_spots
            spots = None
        else:
            type_spotsL = type_spots.split(" - ")
            Type = type_spotsL[0]
            # some facilities have an unkown number of spots
            try:
                spots = type_spotsL[1]
            except:
                spots = None
                # maybe set default as something other than None? "Unkown" ???

            if (Type == "Underground") or (Type == "Covered"):
                Type = "Garage"
            elif Type == "Partially Covered":
                Type = "Lot"


        address_elem = locationContent_elem.find(class_="LocationDetailsContactDetails__detail")
        address_elemL = address_elem.find_all("span")

        addressL = []

        for info in address_elemL:
            addressL.append(info.get_text())

        address = "\n".join(addressL)


        priceInfo_elem = locationContent_elem.find(class_="LocationDetailsPrices")
        
        priceInfoL = []
        
        if priceInfo_elem:
            child_elemL = priceInfo_elem.findChildren()
            
            for i, elem in enumerate(child_elemL):
                info = elem.get_text()

                if "\n" in info:
                    info = " ".join(info.split())

                if (i > 0) and (priceInfoL[-1] == info):
                    continue
                elif info:
                    priceInfoL.append(info)
        else:
            # price info could be empty; set default to free
            priceInfoL.append("Free")


        valet = False
        if "Street" not in Type:
            features_elem = locationContent_elem.find(class_="LocationDetailsFeatures")
            valet_elemL = features_elem.find_all("span")

            valetL = []

            for info in valet_elemL:
                valetL.append(info.get_text())

            if "Valet" in valetL:
                valet = True


#         restriction_elem = locationContent_elem.find(class_="LocationDetailsRestrictions__restriction")
#         restrictionsL = []

#         if restriction_elem:
#             restriction_elemL = restriction_elem.find_all("span")

#             restrictionsL = []

#             for info in restriction_elemL:
#                 restrictionsL.append(info.get_text())

                
        restrictionsL = []
        restriction_elemL = locationContent_elem.find_all(class_="LocationDetailsRestrictions__restriction")

        for restriction_elem in restriction_elemL:

            if restriction_elem:
                restriction_elemL = restriction_elem.find_all("span")

            #     restrictionsL = []

                for info in restriction_elemL:
                    if info.get_text() != "This parking spot is closed during the times you have selected":
                        restrictionsL.append(info.get_text())
        
        
        
                
                
#         print(priceInfoL)
        
        # newlist = remove_redundancies(old_list)
        priceInfoL = remove_redundancies(priceInfoL)
        priceInfoL = remove_redundancies(priceInfoL)
        
#         print()
#         print(priceInfoL)
#         print()

        for i, info in enumerate(priceInfoL):       
#             print(info)
            while ("Month" in priceInfoL[i]) or ("Event" in priceInfoL[i]):
#                print(priceInfoL[i], priceInfoL[i+1], priceInfoL[i+2])
                
#                 print(info)
                if (len(priceInfoL) > i+2+1)  and ("(" in priceInfoL[i+2]):
#                     print("hi")
#                     print(priceInfoL[i], priceInfoL[i+1], priceInfoL[i+2])
#                     print()
#                     print(priceInfoL[i+2])
                    del priceInfoL[i+2]
                    
#                 print(priceInfoL[i+1]) 
                del priceInfoL[i+1]
#                 print(priceInfoL[i])
                del priceInfoL[i]
                
                try:
                    x = priceInfoL[i]
                except:
                    break
                
#                 print(info, priceInfoL[i])
#         print()
#         print(priceInfoL)
                
        # rewrite this more efficiently
        for i, info in enumerate(priceInfoL): 
            if ( ("Out by" in priceInfoL[i]) or ("In after" in priceInfoL[i]) ):
#                 print(i, info, priceInfoL[i-2])
                priceInfoL[i-2] = "Flat Rate"
             # switch if and elif  !!!  
        
        
            elif "Customer" in info:
                infoL = info.split(" - ")[1:]
                priceInfoL[i] = " ".join(infoL)
                


        daysL = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"]



        attendant = False
        if ("Street" not in Type) and (locationContent_elem.find(class_="LocationDetailsPaymentOptions")) and ( "Attendant" in locationContent_elem.find(class_="LocationDetailsPaymentOptions").get_text() ):
            attendant = True



        # formatting "opening times" section to proper dictionary range

        if (len(priceInfoL) == 1) and (priceInfoL[0] == "Free"):
            times_open_elem = locationContent_elem.find_all(class_="LocationDetailsSection")[1]
        else:
            times_open_elem = locationContent_elem.find_all(class_="LocationDetailsSection")[2]
        times_open = times_open_elem.find_all("div")
        times_open = [i.get_text() for i in times_open]
        
#         print(times_open)

        # check that it's not empty
        if (times_open) and (times_open[0]):
#             print(times_open)
#             print()

            times_open = remove_redundancies(times_open)
            times_open = remove_redundancies(times_open)

            times_openL = []
#             print(times_open)
#             print()
            
            for i, info in enumerate(times_open):
#                 print(info)
                if "," not in info:
                    
                    if ":" in info:
                        info = " ".join( info.split() )

                    if (len(info) > 8) and (info[4:7] in daysL):
                        days = info[:7]
                        time = info[7:]
                        times_openL.append(days)
                        times_openL.append(time)
                    elif (len(info) > 3) and (info[:3] in daysL):
                        days = info[:3]
                        time = info[3:]
                        times_openL.append(days)
                        times_openL.append(time)
                    else:
                        times_openL.append(info)
                else:
                    colon_idx = info.find(":")
                    if info[colon_idx-2].isdigit():
                        time = " ".join( info[colon_idx-1:].split() )
                        days_rangeL = info[:colon_idx-2].split(",")
                        
                        for days in days_rangeL:
                            times_openL.append(days)
                            times_openL.append(time)
                    else:
                        time = " ".join( info[colon_idx-1:].split() )
                        days_rangeL = info[:colon_idx-1].split(",")
                        
                        for days in days_rangeL:
                            times_openL.append(days)
                            times_openL.append(time)

            times_openL_copy = times_openL.copy()

#             print(times_openL_copy)

            # removing duplicate sets ??? !!!
            for i, info in enumerate(times_openL_copy):
                if (i>2) and ( (times_openL_copy[i-1], times_openL_copy[i]) == (times_openL_copy[i-3], times_openL_copy[i-2]) ):
                    del times_openL_copy[i]
                    del times_openL_copy[i-1]
            for i, info in enumerate(times_openL_copy):
                if (i>2) and ( (times_openL_copy[i-1], times_openL_copy[i]) == (times_openL_copy[i-3], times_openL_copy[i-2]) ):
                    del times_openL_copy[i]
                    del times_openL_copy[i-1]
            # how to do this iteratively 


            times_open_p1L = []
            no_parking_timesL = []
            no_parkingT_timesL = []

            no_parking_index = len(times_openL_copy)+1
#             print(times_openL_copy)
#             print()
            for i, info in enumerate(times_openL_copy):
#                 print(i, info)
                
                if info == "All day":
                    times_openL_copy[i] = "00:00-24:00"
                elif ":" in info:
                    infoL = re.split(" |-", info)
#                     print(i, infoL)
                    
                    infoL = [convertToMilitaryT(i) for i in infoL if i]
                    times_openL_copy[i] = infoL[0]+"-"+infoL[1]
                elif "No Parking" in info:
                    if no_parking_index != len(times_openL_copy)+1:
#                         print("hi", times_openL_copy[i])
                        del times_openL_copy[i]
                    else:
                        no_parking_index = i
                    # make sure this didn't make code worse ??? !!!

            # print(times_openL_copy)
            # print(times_openL_copy[:no_parking_index])

            times_open_p1L = times_openL_copy[:no_parking_index]
            # making them into a list of tuples
            times_openT_p1L = []
            for i, info in enumerate(times_open_p1L):
                # since the index starts with 0, the second item's remainder isn't 0
                if i%2:
                    times_openT_p1L.append( (times_open_p1L[i-1], times_open_p1L[i]) )

            if no_parking_index != len(times_openL_copy)+1:
                no_parking_timesL = times_openL_copy[no_parking_index+1:]
                # making them into a list of tuples
                
#                 print(no_parking_timesL)
                if "-" in no_parking_timesL[1]:
                    no_parking_timesL[1] = no_parking_timesL[0]+"-"+no_parking_timesL[1][1:]
                    del no_parking_timesL[0]

                no_parkingT_timesL = []
            #     print(no_parking_timesL)
                for i, info in enumerate(no_parking_timesL):
                    # since the index starts with 0, the second item's remainder isn't 0
                    if i%2:
                        no_parkingT_timesL.append( (no_parking_timesL[i-1], no_parking_timesL[i]) )
        else:
            times_open = None
            times_openT_p1L = None

        
        # !!! ??? ***
        # no_parkingT_timesL need to be subtracted from the times_openT_p1L
        
    #     print(no_parkingT_timesL)
        # make into a dict with price
        work_timesL_var = []
        work_timesL_flat = []
        work_timesL_valet = []
        # valet ???; indoor/outdoor ???

        # tuples with rate increment and price ???
        rateL_var = []
        rateL_flat = []

        # or whatever a full day is; in hours
        max_t = "cond"
        max_time = 24
        max_price_var = None
        flat_fee_per_time_weekL = []

        # where the key is the time increment and the value is the price
        increment_varD = {}

        increment_var = 0
        # # flat increment is for flat and valet
        # increment_flat = 0

        for i, info in enumerate(priceInfoL):
        #     print(info)
            
            if "Validation" in info:
                del priceInfoL[i+2]
                del priceInfoL[i+1]
                del priceInfoL[i]
                continue
                
            
            if len(priceInfoL) >= i+3+1:
                if ((daysL[0] in info) or (daysL[1] in info) or (daysL[2] in info) or (daysL[3] in info) or (daysL[4] in info) or (daysL[5] in info) or (daysL[6] in info)) and ( (len(work_timesL_var) == 0) or (priceInfoL[i-1] in work_timesL_var) or ("Min" in priceInfoL[i+1]) or ("Hour" in priceInfoL[i+1]) or ("Min" in priceInfoL[i+3]) or ("Hour" in priceInfoL[i+3]) or (priceInfoL[i-2] == "Holiday") ):
                    if (priceInfoL[i-1] not in work_timesL_var) and ("," not in priceInfoL[i-1]):
                        work_timesL_var.append("FOR NEW RATE")
                    # make sure this doesn't mess up code
                    
                    if "," not in info:
                        work_timesL_var.append(info)
                    else:
#                       info = "Mon-Tue,Thu,Sun 8:30am - 5:30pm"
                        infoL = re.split(" |,", info)
                        time_infoL = []
                        day_infoL = []

                        for info in infoL:
                            if (info in daysL) or (info.split("-")[0] in daysL):
                                day_infoL.append(info)
                            else:
                                time_infoL.append(info)
                                
                        for day_info in day_infoL:
                            time_infoL_copy = time_infoL.copy()
                            time_infoL_copy.insert(0, day_info)
                            work_timesL_var.append( " ".join(time_infoL_copy) )

                    if rateL_var and (rateL_var[-1] != "FOR NEW TIME"):
                        rateL_var.append("FOR NEW TIME")
            else:
                if ((daysL[0] in info) or (daysL[1] in info) or (daysL[2] in info) or (daysL[3] in info) or (daysL[4] in info) or (daysL[5] in info) or (daysL[6] in info)) and ( i+1 < len(priceInfoL) ) and ( (len(work_timesL_var) == 0) or (priceInfoL[i-1] in work_timesL_var) or ("Min" in priceInfoL[i+1]) or ("Hour" in priceInfoL[i+1]) or (priceInfoL[i-2] == "Holiday") ):
                    if priceInfoL[i-1] not in work_timesL_var:
                        work_timesL_var.append("FOR NEW RATE")
                    
                    if "," not in info:
                        work_timesL_var.append(info)
                    else:
#                       info = "Mon-Tue,Thu,Sun 8:30am - 5:30pm"
                        infoL = re.split(" |,", info)
                        time_infoL = []
                        day_infoL = []

                        for info in infoL:
                            if (info in daysL) or (info.split("-")[0] in daysL):
                                day_infoL.append(info)
                            else:
                                time_infoL.append(info)
                                
                        for day_info in day_infoL:
                            time_infoL_copy = time_infoL.copy()
                            time_infoL_copy.insert(0, day_info)
                            work_timesL_var.append( " ".join(time_infoL_copy) )

                    if rateL_var and (rateL_var[-1] != "FOR NEW TIME"):
                        rateL_var.append("FOR NEW TIME")
            

            if "Max" in info:
#                 print(info)
                if "$" in priceInfoL[i+1]:
                    max_price_var = float(priceInfoL[i+1][1:])
                else:
                    if max_t == "cond":
                        # in hours; so 15 min -> 0.25 hr
                        max_t = priceInfoL[i+1].split()
#                         print(max_t)
                        
                        if "min" in max_t[1]: 
                            max_time = int(max_t[0])/60
                        elif "day" in max_t[1]: 
                            max_time = int(max_t[0])*24
                        else:
                            max_time = int(max_t[0])

            # what is the flat or varied work times are divided into more than 3 sections

        #     elif (priceInfoL[i-1] in [work_times, work_times2, work_times3]) and 



#             if ("Flat" in info) and ("Valet" not in priceInfoL[i-1]) and (priceInfoL[i-1][:3] not in daysL) and ("(" not in priceInfoL[i-1]):
            if ("Flat" in info) and ("Valet" not in priceInfoL[i-1]) and (priceInfoL[i-1][:3] not in daysL) :
                # first element in tuple is the flat rate and the second element is the time pretaining to it
                
                if len(priceInfoL) <= i+2:
#                     error ???
                    work_timesL_flat.append((priceInfoL[i+1], "In after 12am Out by 12am"))
                else:
                    work_timesL_flat.append((priceInfoL[i+1], priceInfoL[i+2]))
                    # if week days given without hours, use the hours of operation

        #     print(times_openT_p1L[-1][-2])
#             print(priceInfoL[i-1].split())
        #     print()
#             print(times_openT_p1L)

            if (len(priceInfoL) == 1) and (priceInfoL[0] == "Free"):
                for times_openT in times_openT_p1L:
                    day_range = times_openT[0]
                    time_range = times_openT[1]
                    flat_fee = "$0"

                    flat_fee_per_time_weekL.append( (day_range, time_range, flat_fee) )
            elif ( (info == "Free") and (times_openT_p1L[-1][-2] in priceInfoL[i-1]) ) or ( (info == "Free") and ("Max" in priceInfoL[i-2]) and (times_openT_p1L[-1][-2] in priceInfoL[i-3]) ):
                for times_openT in times_openT_p1L:
                    day_range = times_openT[0]
                    time_range = times_openT[1]
                    flat_fee = "$0"

                    flat_fee_per_time_weekL.append( (day_range, time_range, flat_fee) )
            
            elif ("Flat" in info) and ("(" not in priceInfoL[i-1]) and (priceInfoL[i-1]) and ( (priceInfoL[i-1].split()[0] in daysL) or (priceInfoL[i-1].split("-")[0] in daysL) ):
                flat_daysL= []
                flat_daysL.append(priceInfoL[i-1])
                
                if ("(" not in priceInfoL[i-2]) and ( (priceInfoL[i-2].split()[0] in daysL) or (priceInfoL[i-2].split("-")[0] in daysL) ):
                    flat_daysL.append(priceInfoL[i-2])
                if ("(" not in priceInfoL[i-3]) and ( (priceInfoL[i-3].split()[0] in daysL) or (priceInfoL[i-3].split("-")[0] in daysL) ):
                    flat_daysL.append(priceInfoL[i-3])
                    
#                 print(flat_daysL)
#                 print()
                for flat_days in flat_daysL:
                    if flat_days.split()[2] == "All":
#                         print(flat_days.split("-"))
                        
                        day_range = flat_days.split(" - ")[0]
                        time_range = "00:00-24:00"
                    else:
                        flat_infoL = flat_days.split()
                        
                        day_range = flat_infoL[0]
                        time_rangeL = []
                        
#                         print(flat_infoL)
#                         print()
                        for info in flat_infoL:
                            if ":" in info:
                                time_rangeL.append(info)
                        
#                         print(time_rangeL)
                        infoL = [convertToMilitaryT(i) for i in time_rangeL if i]
                        time_range = infoL[0]+"-"+infoL[1]
                        
                    flat_fee_per_time_weekL.append( (day_range, time_range, priceInfoL[i+1]) )

                                
            
#             print(flat_fee_per_time_weekL)
            
            if "Valet" in info:
                work_timesL_valet.append((info, priceInfoL[i+2]))

            # the variable parking prices
            if ( ("Min" in priceInfoL[i-1]) or ("Hour" in priceInfoL[i-1]) ) and ( (priceInfoL[i-1].split()[0].isdigit()) or (isfloat(priceInfoL[i-1].split()[0])) ):
                increment_varD[priceInfoL[i-1]] = info

                rateL_var.append( (priceInfoL[i-1], info) )




#         print(work_timesL_flat)
#         print(flat_fee_per_time_weekL)
        # expanding the days range to seperate days
        flat_fee_per_time_weekL_copy = flat_fee_per_time_weekL.copy()
        flat_fee_per_time_weekL = []

        if flat_fee_per_time_weekL_copy:
            for rangeT in flat_fee_per_time_weekL_copy:
                time_range = rangeT[1]
                price = rangeT[2]

                day_range = rangeT[0]
    #             print(day_range)
    #             print(rangeT[1])
    #             print()
                opening_time = rangeT[1].split("-")[0]
                closing_time = rangeT[1].split("-")[1]
            #     print(day_range)

                if "-" in day_range:
                    day_rangeL = day_range.split("-")
                    start_day = day_rangeL[0]
                    end_day = day_rangeL[1]
                    start_day_idx = daysL.index(start_day)
                    end_day_idx = daysL.index(end_day)

                    for day in daysL[start_day_idx : end_day_idx+1]:
                        flat_fee_per_time_weekL.append( (day, time_range, price) )
                else:
                    flat_fee_per_time_weekL.append( (day_range, time_range, price) )



    #     print(work_timesL_flat)




        # section to create flat fee rate tuples 
        days_openL = []


        if times_openT_p1L:
            for rangeT in times_openT_p1L:
                day_range = rangeT[0]
    #             print(day_range)
    #             print(rangeT[1])
    #             print()
                opening_time = rangeT[1].split("-")[0]
                closing_time = rangeT[1].split("-")[1]
            #     print(day_range)

                if "-" in day_range:
                    day_rangeL = day_range.split("-")
                    start_day = day_rangeL[0]
                    end_day = day_rangeL[1]
                    start_day_idx = daysL.index(start_day)
                    end_day_idx = daysL.index(end_day)

                    for day in daysL[start_day_idx : end_day_idx+1]:
                        days_openL.append( (day, opening_time, closing_time) )
                else:
                    days_openL.append( (day_range, opening_time, closing_time) )


        # want format: work_timesL_flat.append( (day_range, time_range, flat_fee) )

    #     flat_fee_per_time_weekL = []
#         print(work_timesL_flat)

        for flat_info in work_timesL_flat:
            flat_fee = flat_info[0]

            day_range_start = ""
            day_range_end = ""
            day_range_start_idx = None
            day_range_end_idx = None
            time_range_start = ""
            time_range_end = ""

            flat_info_times = flat_info[1]
        #     print(flat_info_times)
            if flat_info_times[-1] == ")":
                flat_info_times = flat_info_times[:-1]
            if flat_info_times[0] == "(":
                flat_info_times = flat_info_times[1:]
#             print(flat_info_times)

            time_range_infoL = flat_info_times.split()
    #         print(time_range_infoL)


        #         print(time_range_infoL)

            for i, info in enumerate(time_range_infoL):
                if (info == "In") and (time_range_infoL[i+1] == "after"):
                    time_range_start = time_range_infoL[i+2]
                    if ":" not in time_range_start:
                        idx = time_range_start.find("m")-1
                        time_range_startL = list(time_range_start)
                        time_range_startL.insert(idx, ":00")
                        time_range_start = "".join( time_range_startL)

                    time_range_start = convertToMilitaryT(time_range_start)
                elif (info == "Out") and (time_range_infoL[i+1] == "by"):
                    time_range_end = time_range_infoL[i+2]
                    if time_range_end == "close":
                        time_range_end = "12:00am"
                    elif ":" not in time_range_end:
                        idx = time_range_end.find("m")-1
                        time_range_endL = list(time_range_end)
                        time_range_endL.insert(idx, ":00")
                        time_range_end = "".join( time_range_endL) 

                    time_range_end = convertToMilitaryT(time_range_end)
                    if time_range_end == "00:00":
                        time_range_end = "24:00"
                        
                # adding day range info
                elif (info in daysL) or (info.split("-")[0] in daysL):
                    day_rangeL = info.split("-")
                    day_range_start = day_rangeL[0]
                    day_range_end = day_rangeL[-1]
                    day_range_start_idx = daysL.index(day_range_start)
                    day_range_end_idx = daysL.index(day_range_end)
                    
            
            # make sure this didnt mess up code
#             print(day_range_start)
            if day_range_start:
                for day_timeT in daysL[day_range_start_idx:day_range_end_idx+1]:
                    day = day_timeT
                    
                    if not time_range_start:
                        time_range_start = day_timeT[1]
                    if not time_range_end:
                        time_range_end = day_timeT[2]

                    time_range = time_range_start+"-"+time_range_end
                    
                    flat_fee_per_time_weekL.append( (day, time_range, flat_fee) )

            else:                        
        #         print(time_range_start, time_range_end)
                if days_openL:
                    for day_timeT in days_openL:
                        day = day_timeT[0]

                        if not time_range_start:
                            time_range_start = day_timeT[1]
                        if not time_range_end:
                            time_range_end = day_timeT[2]

                        time_range = time_range_start+"-"+time_range_end

        #                 print((day, time_range, flat_fee))
                        flat_fee_per_time_weekL.append( (day, time_range, flat_fee) )
                else:
                    for day_timeT in daysL:
                        day = day_timeT

                        if not time_range_start:
                            time_range_start = day_timeT[1]
                        if not time_range_end:
                            time_range_end = day_timeT[2]

                        time_range = time_range_start+"-"+time_range_end

        #                 print((day, time_range, flat_fee))
                        flat_fee_per_time_weekL.append( (day, time_range, flat_fee) )









#         print(work_timesL_var)
#         print()
        work_timesL_var = work_timesL_var[1:]

        for i, info in enumerate(work_timesL_var):
#             print(i, info)
            
            if (":" in info) or ("All" in info):
                infoL = info.split()
            else:
                continue

            if (infoL[1] == "All") or (infoL[2] == "All"):
                infoL = [infoL[0]]+["00:00-24:00"]
            else:
#                 print(infoL)
                infoL = [ infoL[0] ]+[ convertToMilitaryT(infoL[1])+"-"+convertToMilitaryT(infoL[3]) ]

            work_timesL_var[i] = tuple(infoL)

        # print(work_timesL_var)

        work_times_var_groupsL = []
        group_start = 0
        group_stop = 0
        for i, info in enumerate(work_timesL_var):
            if info == "FOR NEW RATE":
                group_stop = i
                work_times_var_groupsL.append( work_timesL_var[group_start:group_stop] )

                group_start = i+1
            elif i == len(work_timesL_var)-1:
                work_times_var_groupsL.append( work_timesL_var[group_start:] )


#         print(rateL_var)
    #     print()

        rates_var_groupsL = []
        group_start = 0
        group_stop = 0
        for i, info in enumerate(rateL_var):
            if info == "FOR NEW TIME":
                group_stop = i
                rates_var_groupsL.append( rateL_var[group_start:group_stop] )

                group_start = i+1
            elif i == len(rateL_var)-1:
                rates_var_groupsL.append( rateL_var[group_start:] )



#         print(work_times_var_groupsL)
#         print(rates_var_groupsL)

    #     print()

        # each element will be a tuple with a day/day-range, time-range, rate incriment, rate price
        rate_per_time_varL = []
        for time_groupL, rateTL in zip(work_times_var_groupsL, rates_var_groupsL):
    #         print(time_groupL, rateTL)


            for time_groupT in time_groupL:
                day_range = time_groupT[0]
                time_range = time_groupT[1]

                for rateT in rateTL:
                    time_inc = rateT[0]
                    price = rateT[1]

                    rate_per_time_varL.append( (day_range, time_range, time_inc, price) )

        # dividing it by days of the week
        rate_per_time_varL_week = []

        for rate_per_timeT in rate_per_time_varL:

            if "-" in rate_per_timeT[0]:
                day_rangeL = rate_per_timeT[0].split("-")
                start_day = day_rangeL[0]
                end_day = day_rangeL[1]

                start_day_idx = daysL.index(start_day)
                end_day_idx = daysL.index(end_day)
        #         print(start_day_idx, end_day_idx)

                for day in daysL[start_day_idx : end_day_idx+1]:
                    rate_per_time_varL_week.append( tuple( [day] + list(rate_per_timeT[1:]) ) )

            else:
                rate_per_time_varL_week.append(rate_per_timeT)


        if not rate_per_time_varL_week:
            max_price_var = None


        if not restrictionsL:
            restrictionsL = None


        rate_per_time_var_weekDL = []

        if rate_per_time_varL_week:
            for rate_per_timeT in rate_per_time_varL_week:
                day = rate_per_timeT[0] 
                time_range = rate_per_timeT[1]
                rate_length = rate_per_timeT[2]
                rate_price = rate_per_timeT[3]

                rate_per_time_var_weekDL.append({"day":day, "time range":time_range, "rate price":rate_price, "rate length":rate_length})
        else:
            rate_per_time_var_weekDL = None
            max_time = None
            # adjust max_time !!! ???



        flat_fee_per_time_weekDL = []

        if flat_fee_per_time_weekL:
            for flat_fee_per_timeT in flat_fee_per_time_weekL:
                day = flat_fee_per_timeT[0] 
                time_range = flat_fee_per_timeT[1]
                rate = flat_fee_per_timeT[2]

                flat_fee_per_time_weekDL.append({"day":day, "time range":time_range, "flat fee":rate})
        else:
            flat_fee_per_time_weekDL = None


        availability = True
        # !!! ???

        droppedL = [7, 92, 111, 141, 146, 235, 266]
        for i in [6, 5, 4, 3, 2, 1, 0]:
            if loc_i > droppedL[i]:
                loc_i -= i+1
                break
                
        
        print(loc_i)
        
        
        addressD = {}
        name = ""
        street_num = ""
        street = ""
        city = ""
        state = ""
        zip_code = ""


        addressL = address.split("\n")

        if len(addressL) == 5:        
            name = addressL[1]

            num_and_street = addressL[2]
            street_num = num_and_street.split()[0]
            street = " ".join( num_and_street.split()[1:] )

        elif len(addressL) == 3:
            name = addressL[0]

            num_and_street = addressL[1]
            if loc_i == 281:
                num_and_street = addressL[0]
            street_num = num_and_street.split()[0]
            street = " ".join( num_and_street.split()[1:] )

        elif len(addressL) == 4:        
            name = addressL[0]

            if name == "Los Angeles Department Of Transportation":
                num_and_street = addressL[1]
                street_num = num_and_street.split()[0]
                street = " ".join( num_and_street.split()[1:] )
            else:
                if addressL[-2] == "Hollywood":
                    num_and_street = addressL[1]
                    street_num = num_and_street.split()[0]
                    street = " ".join( num_and_street.split()[1:] )
                    
                else:
                    name = addressL[1]

                    num_and_street = addressL[2]
                    street_num = num_and_street.split()[0]
                    street = " ".join( num_and_street.split()[1:] )



        city_state_zip = addressL[-1]
        city_state_zipL = city_state_zip.split()
        city = " ".join(city_state_zipL[:2])[:-1]
        state = city_state_zipL[2]
        zip_code = city_state_zipL[3]

        if (Type == 'Street parking') or (loc_i == 281):
            name = None

#         print(addressL)
#         print(street)
        if name:
            addressD["name"] = name
        addressD["street number"] = street_num
        addressD["street"] = street
        addressD["city"] = city
        addressD["state"] = state
        addressD["zip code"] = zip_code
        
        
        
        # safety score calculation: based on street, security, history of crime in that area, and parking type
        safety_score = 100 - loc_crimesD[loc_i]["score_40"]
        if main_streetsD[street] == 0:
            safety_score -= 10
        if Type == "Garage":
            safety_score -= 10
        elif Type == "Lot":
            safety_score -= 5
        if (valet) or (attendant):
            safety_score += 5
        
        
#         if restrictionsL
        
        
        lat_lngD = coordsD[loc_i]
        
        
        parking_locationsD[loc_i] = {"type": Type, 
                                     "spots": spots,
                                     "coordinates": lat_lngD,
                                      "address": addressD, 
                                      "valet": valet, 
                                      "attendant": attendant, 
                                      "restrictions": restrictionsL, 
                                      "availability": availability,
                                      "maximum stay": max_time,
                                     "maximum price": max_price_var,
                                      "safety score": safety_score,
                                      "flat fees": flat_fee_per_time_weekDL, 
                                      "rates": rate_per_time_var_weekDL}

        parking_locationsL.append( {"type": Type, 
                                    "spots": spots,
                                    "coordinates": lat_lngD,
                                  "address": addressD, 
                                  "valet": valet, 
                                  "attendant": attendant, 
                                  "restrictions": restrictionsL, 
                                  "availability": availability,
                                  "maximum stay": max_time,
                                    "maximum price": max_price_var,
                                  "safety score": safety_score,
                                  "flat fees": flat_fee_per_time_weekDL, 
                                  "rates": rate_per_time_var_weekDL} )
#         break
        
    except:
        edit_listL.append(loc_i)

parking_locationsD[211]

print(len(edit_listL))
print()
for i in edit_listL:
    print(i)







# # forward geocoding with postionstack

# access_key = "449a652129c6a5b89684ac6a51cd65ab"

# # for i in range(len(parking_locationsD)):
# for i in (3, 5):
# #     i = 84
#     addressD = parking_locationsD[i]["address"]
    
#     street_num = addressD["street number"] 
#     street = addressD["street"]
#     city = addressD["city"]
#     state = addressD["state"]
#     zip_code = addressD["zip code"] 
    
#     query_address = street_num + " " + street + ", " + city + ", " + state + " " + zip_code
#     print(query_address)
#     print()
    
#     conn = http.client.HTTPConnection('api.positionstack.com')

#     params = urllib.parse.urlencode({
#         'access_key': access_key,
#         'query': "6543 Selma Avenue, Los Angeles",
#         'region': "90028",
#         'limit': 4,
#         })

#     conn.request('GET', '/v1/forward?{}'.format(params))

#     res = conn.getresponse()
#     data = res.read()

# #     print(data.decode('utf-8')   
#     coordD = json.loads( data.decode('utf-8') )

#     print(coordD)
#     break
    
#     lat = coordD["data"][0]["latitude"]
#     long = coordD["data"][0]["longitude"]
          
# #     coordinatesD[i] = {"latitude":lat, "longitude":long}
    
    
#     time.sleep(1)



import time







import googlemaps
#Set Google MAPS API_Key
g_API = "AIzaSyDYDVUyBArHNfFjZnFC12iiv3LadNfwK54"
gmaps_key = googlemaps.Client(key=g_API)

x = gmaps_key.geocode("6543 Selma Ave, Los Angeles, CA 90028")

x[0]["geometry"]["location"]["lat"]

# use geopy for better coordinate accuracy ??? !!! ***

import googlemaps
#Set Google MAPS API_Key
g_API = "AIzaSyDYDVUyBArHNfFjZnFC12iiv3LadNfwK54"
gmaps_key = googlemaps.Client(key=g_API)

coordsD = {}

# forward geocoding with google; runs longer

# best one 

# access_key = "449a652129c6a5b89684ac6a51cd65ab"

for i in range(len(parking_locationsD)):
    addressD = parking_locationsD[i]["address"]
    
    street_num = addressD["street number"] 
    street = addressD["street"]
    city = addressD["city"]
    state = addressD["state"]
    zip_code = addressD["zip code"] 
    
    query_address = street_num + " " + street + ", " + city + ", " + state + " " + zip_code
#     print(query_address)
#     print()


    coordinate_infoD = gmaps_key.geocode(query_address)
    

    lat = coordinate_infoD[0]["geometry"]["location"]["lat"]
    long = coordinate_infoD[0]["geometry"]["location"]["lng"]
          
    coordsD[i] = {"latitude":lat, "longitude":long}
    
    
    time.sleep(1)











with open("coordD", "wb") as f:
    pickle.dump(coordsD, f)

with open ("parking_locationsD_final", "wb") as f:
    pickle.dump(parking_locationsD, f)





import json
import requests
import pandas as pd


# base url of my firebase project's realtime database 
fb_url = "https://dsci551-project-parking-app-default-rtdb.firebaseio.com/"
json_ext = ".json"

# converting dictionary into a string
parking_locations_json = json.dumps(parking_locationsD)

put = requests.put(fb_url + json_ext, parking_locations_json)


# This code has been tested multiple times and it works perfectly.
# However, although highly unlikely, sometimes an unforeseen error (e.g. 400 response) occurs due to a server-side issue
if "200" not in str(put):
    error = str(put)[str(put).find("[")+1:-2]
    print("Request returned a " + error + " error (possibly due to a server-side issue). Please try again later.")

put





with open ("coordD2", "rb") as f:
    coordsD = pickle.load(f)

