# -*- coding: utf-8 -*-
"""crime_dataset_processing.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1pNyOBkJc6Yj0B5lZLv9Xzgxni8h7uDVI
"""

import pandas as pd
import geopy
import requests
import geopy.distance
from numpy import interp

path_og = "../Dataset/Crime_Data_from_2020_to_Present.csv"

path = 'crime_dataset.csv'

crime_csv = open(path, "r")
crime_csv_og = open(path_og, "r")

crime_df = pd.read_csv(crime_csv)
crime_df_og = pd.read_csv(crime_csv_og)

pd.set_option("display.max_rows", 25)
# pd.set_option("display.max_columns", 10)
# pd.set_option('display.max_rows', None)
pd.set_option("display.max_columns", None)

# list of columns to drop
del_colL = ["Cross Street", "Crm Cd 4", "Crm Cd 3", "Crm Cd 2", "Crm Cd 1", "Status Desc", "Status", "Weapon Used Cd", "Mocodes", "Crm Cd", "Part 1-2", "Rpt Dist No", "AREA", "TIME OCC", "Date Rptd"]

for col in del_colL:
    # axis 1: columns
    crime_df.drop(col, inplace=True, axis=1)



crime_df.set_index("Unnamed: 0", inplace=True)

display(crime_df_og)





# list of my target zip codes (and the ones touching them)
zip_codesL = ["90027", "90028", "90029", "90038", "90046", "90068", "90004", "90036"]

areaL = ["Hollywood", "Wilshire", "Olympic", "Northeast", "Rampart", "West LA", "Southwest", "N Hollywood"]

geolocator = geopy.Nominatim(user_agent='1234')
location = geolocator.reverse((34.0141, -118.2978))

zip_code = location.raw["address"]["postcode"]

for row in crime_df.itertuples():
    rowL = (list(row))
    row_id = rowL[0]
    print(row_id)
    
    lat = rowL[-2]
    long = rowL[-1]
    
#     print(rowL)
    
    if (not lat) or (not long):
        crime_df.drop(row_id, inplace=True, axis=0)
        continue
    
    area = rowL[3]
    if area not in areaL:
        crime_df.drop(row_id, inplace=True, axis=0)
        continue
    
    
    location = geolocator.reverse((lat, long))
    
    if "postcode" not in location.raw["address"]:
        continue
    
    zip_code = location.raw["address"]["postcode"]
    
    # drop all rows (ie crime incidents) that occured out the 6 zip codes
    if zip_code not in zip_codesL:
        # axis 0: rows
        crime_df.drop(row_id, inplace=True, axis=0)
    
#     break

display(crime_df)



crime_dataset_csv = crime_df.to_csv('crime_dataset.csv', index=True)









# base url of my firebase project's realtime database
fb_url = "https://dsci551-project-parking-app-default-rtdb.firebaseio.com/"
json_ext = ".json"

get = requests.get(fb_url + json_ext)
all_parking_locsD = get.json()

# all_parking_locsD[0]

all_parking_locsD_copy = all_parking_locsD.copy()

park_loc_crimeD = {}

for i in range(335):
    print(i)
    print(all_parking_locsD_copy[i]["coordinates"])
    
    park_loc_crimeD[i] = all_parking_locsD_copy[i]["coordinates"]

park_loc_crimeD



for i in range(335):
    print(i)
    
    parking_lat = park_loc_crimeD[i]['latitude']
    parking_long = park_loc_crimeD[i]['longitude']

    crimesL = []

    for row in crime_df.itertuples():
        rowL = (list(row))
        crime_id = rowL[0]

        crime_lat = rowL[-2]
        crime_long = rowL[-1]

        distance = geopy.distance.geodesic((parking_lat, parking_long), (crime_lat, crime_long)).mi 
        
#         print(distance)

        # select all crime that occured within a 0.25 mile radius of the parking location; immediate vicinity (5 min)
        if distance <= 0.25:
            crimesL.append(crime_id)

#     print()
#     print(crimesL)
#     break
    park_loc_crimeD[i]['crimesL'] = crimesL

len(park_loc_crimeD[0]["crimesL"])



for i in range(335):
    print(i)
#     i = 9
    
    # crime_score 
    tot_score = 0
    # add 1 for any crime; multiply by 3 if it is a violent crime; multiply by 2 if it is car or parking lot related
    
    crimesL = park_loc_crimeD[i]['crimesL']
    
    for crime_id in crimesL:
#         crime_id = 9
    
        score = 1
        
        crime_dataL = list(crime_df.loc[crime_id])
        # iloc is integer based; loc is label based
#         print(crime_dataL)

        # if a weapon was used -- and not for vandalism
        if (crime_dataL[-4]) and ("VANDALISM" not in crime_dataL[3]):
            score *= 3
            
        # if the crime had to do with a car or parking location
        if ( (type(crime_dataL[8]) == str) and ("PARKING" in crime_dataL[8]) ) or ( (type(crime_dataL[8]) == str) and ("GARAGE" in crime_dataL[8]) ) or ( (type(crime_dataL[3]) == str) and ("VEHICLE" in crime_dataL[3]) ):
            score *= 2
#             premis desc: PARKING LOT, GARAGE/CARPORT, PARKING UNDERGROUND/BUILDING, ...
#             crime desc: VEHICLE, ...
            
        tot_score += score
        
#         break
#     break
    
    park_loc_crimeD[i]['score'] = tot_score
    
    print(tot_score)
    print()

print(tot_score)

print(len(crimesL))

crime_scoresL = [park_loc_crimeD[i]["score"] for i in range(335)]

crime_scoresL

crime_score_max = max(crime_scoresL)
crime_score_min = min(crime_scoresL)



# from numpy import interp

# We want to map a range of numbers into a difference range -- while maintaining the relationships/ratios the same
# numpy's inter function's first parameter is value being mapped
# The second is a list with the old range min and old range max
# The third is a list with the new range min and new range max

# adjusting the crime scores to be between 0-40 
crime_scoresL_40 = [round( interp(score, [738, 9576], [0, 40]) ) for score in crime_scoresL]



crime_scoresL_40

for i, score_40 in enumerate(crime_scoresL_40):
    park_loc_crimeD[i]["score_40"] = score_40

park_loc_crimeD[217]["score_40"]









import pickle

with open ("loc_crimesD", "wb") as f:
    pickle.dump(park_loc_crimeD, f)

