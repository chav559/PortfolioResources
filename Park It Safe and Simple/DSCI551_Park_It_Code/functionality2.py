# -*- coding: utf-8 -*-
"""functionality2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1BnYZaE6UTuhWxWRJnKWIM-e-cJEX_70-
"""

import json
import requests
from datetime import datetime

# could instead use: from geopy.geocoders import Nominatim ???
import googlemaps
# Google MAPS API_Key
g_API = "AIzaSyDYDVUyBArHNfFjZnFC12iiv3LadNfwK54"
gmaps_key = googlemaps.Client(key=g_API)

import geopy.distance

import imaplib, email
user = 'dsciproject551@gmail.com'
password = 'FMarseille1'
imap_url = 'imap.gmail.com'



# base url of my firebase project's realtime database
fb_url = "https://dsci551-project-parking-app-default-rtdb.firebaseio.com/"
json_ext = ".json"

daysL = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"]
daysL_full = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"]



# functionality 2

# At the top include a short explanation of the functionality; ie what it is used for ???

# display all information of a specific parking location 
# find closest address based on long/lat
    # in case the user's inputed address and official address for the parking spot aren't a 1-to-1 match


# user input: street number, street name, zip code, city, and choose 1 of 3 parking types (optional)
# based on front-end user input

# parking_type is None (ie not specified) -- by default
# parking_type = None

def location_description(street_num=None, street_name=None, zip_code=None, city=None, parking_type=None, loc_id=None):
    state = "CA"
    output_str = ""
    output2_str = ""
    rel_incidents_str = ""
    
    if (not loc_id) and (zip_code not in ["90028", "90038"]):
        output_str += "This address is outside of our current scope of operation. \nPlease input an address within zip code 90028 or 90038."
        return output_str, rel_incidents_str, output2_str, loc_id
    
    now = datetime.now()
    
    
    if (type(loc_id) == int) or ( (type(loc_id) == str) and (loc_id.isdigit()) ):
        if (int(loc_id) < 0) or (int(loc_id) > 334):
            loc_id = None
    
    if loc_id:
        locationD = requests.get(fb_url + str(loc_id) + json_ext).json()
#         print(1)
    else:
        # return the json parking data from FB
        # firebase has only filtering by only 1 orderBy attribute
        # so we can reduce the number of location by 100-200 items -- no more

        # if its street parking; use zip code instead
        if parking_type == "Garage":
            get = requests.get(fb_url + json_ext + '?orderBy="type"&equalTo="Garage"')
            parking_locsD = get.json()

        elif parking_type == "Lot":
            get = requests.get(fb_url + json_ext + '?orderBy="type"&equalTo="Lot"')
            parking_locsD = get.json()

        else:
            get = requests.get(fb_url + json_ext + '?orderBy="address/zip code"&equalTo="%s"' %zip_code)
            parking_locsD = get.json()
    
    
    
        # forward geocoding with google
        query_address = street_num + " " + street_name + ", " + city + ", " + state + " " + zip_code

        # using the googlemaps API 
        coordinate_infoD = gmaps_key.geocode(query_address)

        if coordinate_infoD:
            lat = coordinate_infoD[0]["geometry"]["location"]["lat"]
            long = coordinate_infoD[0]["geometry"]["location"]["lng"]
        else:
            output_str += "Invalid input. \nPlease make sure the address fields are properly filled in and try again."
            return output_str, rel_incidents_str, output2_str, loc_id

        # coordinates for user inputted address
        coords1 = (lat, long)



        min_dist = float("inf")
        # loc_id is the ID for parking location with smallest distance from coords1
        loc_id = None

        # calculating distances between two coordinates
        # find the one with the shortest distance and output its info
        for i, loc_infoD in parking_locsD.items():

            lat = loc_infoD["coordinates"]["latitude"]
            long = loc_infoD["coordinates"]["longitude"]
            coords2 = (lat, long)

            # distance between coordinates
            distance = geopy.distance.geodesic(coords1, coords2).km

            if distance < min_dist:
                min_dist = distance
                loc_id = i

        locationD = parking_locsD[loc_id]
#         print(2)
    
    
    
    
    
    # calculating new Safety Score based on citizen data (from parsing emails)
    # for now, manually delete the old emails -- eg before emails; set up later
    
    # keywords used to identify whether the Citizen alert is relevant to safety
    crime_keywordsL = ["shot", "slash", "armed", "fire", "gun", "stab", "knife", "blaze", "homicide", "rob", "carjack", "police", "vehicle"]

    # list of dictionaries with possibly relevant citizen incident info
    incidentsL = []
    
    mail = imaplib.IMAP4_SSL('imap.gmail.com')
    mail.login(user, password)
    mail.list()
    # Out: list of "folders" aka labels in gmail.
    mail.select("inbox") 
    # connect to inbox.

    if now.hour >= 12:
        search_date = str( now.day ) + "-" + now.strftime("%b") + "-" + now.strftime("%Y")
    else:
        search_date = str( now.day-1 ) + "-" + now.strftime("%b") + "-" + now.strftime("%Y")

    # result, data = mail.search(None, "ALL")
    result, data = mail.search(None, 'SINCE ' + "\"" + search_date + "\"")
    # returns emails for search_date and after

    ids = data[0] # data is a list.
    id_list = ids.split() # ids is a space separated string

    for email_id in id_list:

    #     email_id = id_list[i] # get the latest

        result, data = mail.fetch(email_id, "(RFC822)") # fetch the email body (RFC822) for the given ID
        raw_email = data[0][1]

        email_message = email.message_from_bytes(raw_email)
        email_str = str(email_message)


        time_start = email_str.find(",")
        time_end = email_str.find("-", 10)
        time_ctzn = email_str[time_start+2:time_end]
        time_ctznL = time_ctzn.split()
        day_ctzn = time_ctznL[0]
        hour_ctzn = time_ctznL[-1][:5]

        # selecting crimes that occured withing the last 12 hours of now
        if (int(day_ctzn) == int(now.day)) or ( (int(day_ctzn) == int(now.day)-1) and (int(hour_ctzn[:2]) >= int(now.hour)+12) ):        
            address_start = email_str.find("https://sendgrid.com")
            address_end = email_str.find("https://citizen.com")

            address_ctzn = email_str[address_start+22:address_end-2].strip()
            address_ctzn = address_ctzn.replace("&amp;", "&")
            address_ctznL = address_ctzn.split("\n")

            crime_ctzn = address_ctznL[0]
            address_ctzn = address_ctznL[1] + ", " + address_ctznL[2]

            # selecting only incidents related to safety (based on our set keywords)
            # So, incidents like "Have You Seen Kevin?" don't affect the safety score
            keyword_match = 0
            for keyword in crime_keywordsL:
                if keyword in crime_ctzn.lower():
                    keyword_match += 1
            if not keyword_match:
                # print(crime_ctzn)
                continue

            incidentD = {"day":day_ctzn ,"time":hour_ctzn, "crime":crime_ctzn, "address":address_ctzn}

            # getting coordinates from crime incident address
            coordinate_infoD = gmaps_key.geocode(address_ctzn)
            lat = coordinate_infoD[0]["geometry"]["location"]["lat"]
            long = coordinate_infoD[0]["geometry"]["location"]["lng"]
            incidentD["coordinates"] = {"latitude":lat, "longitude":long}

            incidentsL.append(incidentD)

    
    # relevant incidentsL
    rel_incidentsL = []
    
#     print(locationD)
    # We loop through the incidentsL, and if they are within 0.5 miles from the parking loc (coords), we add it
    parking_lat = locationD["coordinates"]["latitude"]
    parking_long = locationD["coordinates"]["longitude"]

    for incidentD in incidentsL:
        crime_lat = incidentD["coordinates"]["latitude"]
        crime_long = incidentD["coordinates"]["longitude"]

        distance = geopy.distance.geodesic((parking_lat, parking_long), (crime_lat, crime_long)).mi 
    #     print(distance)

        # select all crime incidents that occured within a 0.5 mile radius of the parking location (ie 10 min)
        # since new/currently-occuring crimes are more fluid, I use an expanded radius (vs 0.25 for old crimes)
        if distance <= 0.5:
            rel_incidentsL.append(incidentD)
    
    
    # calculating new crime score (based on how many incidents there were in proximity and how recently)

    # can be either 1, 4, or 12
    # indicating when the crime happened in relation to now; ~ 1 hour ago, 4 hours, or 12 hours ago
    whensL = []

    for incidentD in rel_incidentsL:
        when = 0

        hour_ctzn = incidentD["time"]
        day_ctzn = incidentD["day"]

        if int(day_ctzn) == int(now.day):
            # if it happened within ~ the last 1-2 hours; need to approximate because 1:57 and 1:02 are both 1
            if int(hour_ctzn[:2]) >= int(now.hour)-1:
                when = 1
            elif int(hour_ctzn[:2]) >= int(now.hour)-5:
                when = 4
            else:
                when = 12
        else:
            if (int(hour_ctzn[:2]) == 23) and (int(now.hour) == 0):
                when = 1
            elif int(hour_ctzn[:2]) >= int(now.hour)+24-5:
                when = 4
            else:
                when = 12

        whensL.append(when)


    # the crime score is subtracted from th safety score (before we output it to UI)
    crime_score = 0

    for crime in whensL:
        if crime == 1:
            crime_score += 25
        elif crime == 4:
            crime_score += 10
        elif crime == 12:
            crime_score += 5

    # print(crime_score)
    new_safety_score = locationD["safety score"] - crime_score
    
    
    
    
    
    # parsing all data in (parking) locationD to create the final output string
    
    
    if "name" not in locationD["address"]:
        name = ""
    else:
        name = locationD["address"]["name"] + "  \n"

    address = name + locationD["address"]["street number"] + " " + locationD["address"]["street"] + "  \n" + locationD["address"]["city"] + ", " + locationD["address"]["state"] + " " + locationD["address"]["zip code"]

    # safety_score = locationD["safety score"]
    availability = locationD["availability"]
    if availability:
        availability_str = "There is Space Available"
    else:
        availability_str = "There is No Space Available"
    valet = locationD["valet"]

    if "update time" in locationD:
        update_time = locationD["update time"]
    else:
        update_time = "00:00"

    loc_type = locationD["type"]

    # display along with only "rate" price
    if "maximum stay" in locationD:
        max_stay = locationD["maximum stay"]
    else:
        max_stay = None
    
    if "maximum price" in locationD:
        max_price = locationD["maximum price"]
    else:
        max_price = None

    if "spots" in locationD:
        spots = locationD["spots"]
    else:
        spots = None

    if loc_type == "Lot":
        loc_type = "Parking Lot"
    elif loc_type == "Street parking":
        loc_type = "Street Parking"

    if "restrictions" in locationD:
        restrictionsL = locationD["restrictions"]
    else:
        restrictionsL = None

    rel_incidents_str = ""
    if rel_incidentsL:
        for incidentD in rel_incidentsL:
            cime_str = incidentD["crime"] + " (" + now.strftime("%B") + ", " + incidentD["day"] + " " + incidentD["time"] + ")  \n" +"  \t" + incidentD["address"] + "  \n"
            rel_incidents_str += cime_str
    else: 
        rel_incidents_str += "There are currently no incidents occuring near this location."


    output_str += address + "  \n\n" + loc_type + "  \n"

    if loc_type != "Street Parking":
        if valet == True:
            output_str += "(Offers Valet Parking)\n"
        else:
            output_str += "(Does Not Offer Valet Parking)\n"

    if restrictionsL:
        output_str += "\nParking Restrictions:\n"
        for res in restrictionsL:
            output_str += "\t " + res + "\n"

    if spots:
        output_str += "  \nThere are " + spots.split()[0] + " Parking Spots.  \n"
    output_str += availability_str
    output_str += "  \n(This Was Last Updated At: " + update_time + ")\n"
    output_str += "  \nSafety Score: " + str(new_safety_score)

    # seperate output to return
#     rel_incidents_str
    # can the rel_incidents_str be shown only if something is clicked 
    # if it can't be displayed seperately, just add it to output_str
    
    

    
    # parsing the price/time info
    # add the price info into output2_str

    hour_now = now.hour
    weekday_now = daysL[now.weekday()]

    if now.weekday() == 6:
        weekday_tomorrow = daysL[0]
    else:
        weekday_tomorrow = daysL[now.weekday()+1]


    closed = True
    today_ratesL = []
    tomorrow_ratesL = []

    if "rates" in locationD:
        for rateD in locationD["rates"]:

            if weekday_now == rateD["day"]:
                today_ratesL.append(rateD)
            elif weekday_tomorrow == rateD["day"]:
                tomorrow_ratesL.append(rateD)

    today_flatFeeL = []
    tomorrow_flatFeeL = []

    if "flat fees" in locationD:
        for flatfeeD in locationD["flat fees"]:

            if weekday_now == flatfeeD["day"]:
                today_flatFeeL.append(flatfeeD)
            elif weekday_tomorrow == flatfeeD["day"]:
                tomorrow_flatFeeL.append(flatfeeD)


    if (len(today_ratesL) == 0) and (len(today_flatFeeL) == 0):
        output2_str += "The parking facility is closed today."
        return output_str, rel_incidents_str, output2_str, loc_id



    var_str = ""
    for i in range(len(today_ratesL)):
        transition = False

        if (i != 0) and (transition):
    #         print("or")
            var_str += "\nor"
        elif (i == 0):
    #         print("Hourly Rate Parking\n-------------------")
            var_str += "Hourly Rate Parking  \n-------------------"


        range_start = today_ratesL[i]["time range"].split("-")[0]
        range_end = today_ratesL[i]["time range"].split("-")[1]

        range_start_int = int(range_start[:2])
        range_end_int = int(range_end[:2])

        
        # *****
        if (hour_now >= range_start_int) and (hour_now < range_end_int):
        #     print(today_ratesL)

    #         print(today_ratesL[i]["rate price"], "per", today_ratesL[i]["rate length"])
            var_str += "  \n  " + today_ratesL[i]["rate price"] + " per " + today_ratesL[i]["rate length"]
    #         print(daysL_full[now.weekday()], "between", today_ratesL[i]["time range"])
            var_str += "  \n  " + daysL_full[now.weekday()] + " between " + today_ratesL[i]["time range"]
    #         print("For a maximum stay of", max_stay, "hour(s)")
            if max_stay:
                var_str += "  \nFor a maximum stay of " + str(max_stay) + " hour(s)"
            
            if (max_stay) and (max_price):
                var_str += "  \n  With a maximum price of $" + str(max_price)  + "\n"
            elif (not max_stay) and (max_price):
                var_str += "  \n  And a maximum price of $" + str(max_price)  + "\n"
            else:
                var_str += "  \n"

            closed = False
            transition = True

        else:
            if (loc_type == "Street Parking") and (hour_now < range_start_int):

                # add street parking no parking times
    #             print("Free")
                time_range_inverse = "-".join( ["00:00", range_start] )
                add_str = "  \n" + "Free" + "  \n  " + daysL_full[now.weekday()] + " between " + time_range_inverse
                if add_str not in var_str:
                    var_str += "  \n" + "Free"
    #             print(daysL_full[now.weekday()], "between", time_range_inverse)
                    var_str += "  \n  " + daysL_full[now.weekday()] + " between " + time_range_inverse
                    if max_stay:
        #                 print("For a maximum stay of", max_stay, "hour(s)")
                        var_str += "  \n" + "For a maximum stay of " + str(max_stay) + " hour(s)" + "\n"


                closed = False
                transition = True

            elif (loc_type == "Street Parking") and (hour_now >= range_end_int):

                if tomorrow_ratesL and (len(tomorrow_ratesL) > i):
                    tom_range_start = tomorrow_ratesL[i]["time range"].split("-")[0]
                else:
                    tom_range_start = "24:00"

    #             print("Free")
                time_range_inverse = "-".join( [range_end, tom_range_start] )
                add_str = "\n" + "Free" + "  \n  " + daysL_full[now.weekday()] + " between " + time_range_inverse + "\n"
                if add_str not in var_str:
                    var_str += "\n" + "Free"
        #             print(daysL_full[now.weekday()], "between", time_range_inverse)
                    var_str += "  \n  " + daysL_full[now.weekday()] + " between " + time_range_inverse + "\n"


                closed = False
                transition = True



    flat_str = ""
    for i in range(len(today_flatFeeL)):
        transition = False

        if (i != 0) and (transition):
    #         print("or")
            flat_str += "\nor"
        elif (i == 0):
    #         print("Flat Fee Parking\n-------------------")
            flat_str += "Flat Fee Parking  \n-------------------"

        range_start = today_flatFeeL[i]["time range"].split("-")[0]
        range_end = today_flatFeeL[i]["time range"].split("-")[1]

        range_start_int = int(range_start[:2])
        range_end_int = int(range_end[:2])


        if (hour_now >= range_start_int) and (hour_now < range_end_int):
        #     print(today_ratesL)

            if (i != 0) and (today_flatFeeL[i-1]["time range"] == today_flatFeeL[i]["time range"]):
                valet = " (Valet)"
            else:
                valet = ""

    #         print("Flat Rate of", today_flatFeeL[i]["flat fee"] + valet)
            flat_str += "\n" + "Flat Rate of " + today_flatFeeL[i]["flat fee"] + valet
    #         print(daysL_full[now.weekday()], "between", today_flatFeeL[i]["time range"])
            flat_str += "  \n  " + daysL_full[now.weekday()] + " between " + today_flatFeeL[i]["time range"] + "\n"

            closed = False
            transition = True


        else:
            if (loc_type == "Street Parking") and (hour_now < range_start_int):

    #             print("Free")
                flat_str += "\n" + "Free"
                time_range_inverse = "-".join( ["00:00", range_start] )
    #             print(daysL_full[now.weekday()], "between", time_range_inverse)
                flat_str += "  \n  " + daysL_full[now.weekday()] + " between " + time_range_inverse

                closed = False
                transition = True

            elif (loc_type == "Street Parking") and (hour_now >= range_end_int):

                if tomorrow_ratesL:
                    tom_range_start = tomorrow_ratesL[0]["time range"].split("-")[0]
                else:
                    tom_range_start = "24:00"

    #             print("Free")
                flat_str += "\n" + "Free"
                time_range_inverse = "-".join( [range_end, tom_range_start] )
    #             print(daysL_full[now.weekday()], "between", time_range_inverse)
                flat_str += "  \n  " + daysL_full[now.weekday()] + " between " + time_range_inverse + "\n"

                closed = False
                transition = True


    if closed:
        output2_str += "  \nThe parking location is closed at this time.  \nNo parking allowed."


    if (var_str) and (var_str != "Hourly Rate Parking\n-------------------"):
        output2_str += "\n\n" + var_str

    if flat_str != "Flat Fee Parking\n-------------------":
        output2_str += "\n\n" + flat_str


    return output_str, rel_incidents_str, output2_str, loc_id



# user input

# street_num = "1460"
# street_name = "Mansfield Avenue"
# zip_code = "90028"
# city = "Los Angeles"
# parking_type = ""
# state = "CA"

street_num = "6560"
street_name = "Sunset"
zip_code = "90028"
city = "Los Angeles"
parking_type = None
state = "Caifornia"

# output_str, rel_incidents_str, output2_str, loc_id = location_description(street_num, street_name, zip_code, city)


output_str, rel_incidents_str, output2_str, loc_id = location_description(street_num, street_name, zip_code, city, parking_type)


# if they click the hyperlink in functionality 3 page to redirect for a specific address at funcationality 2
# should get the location_id from the UI

# parking_loc_id = 120
# output_str, rel_incidents_str, output2_str, loc_id = location_description(loc_id=166)

print(output_str)

print(rel_incidents_str)

print(output2_str)





























